<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Magical Floating Christmas Village</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
            font-family: 'Noto Sans KR', sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            font-size: 1.2rem;
            pointer-events: none;
            transition: opacity 0.5s;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            text-align: center;
        }
        .controls-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
            pointer-events: none;
            text-shadow: 0 1px 5px rgba(0,0,0,0.8);
            text-align: center;
        }
    </style>
</head>
<body>

<div id="loading">ğŸŒ• í•˜ëŠ˜ì— ë‹¬ì„ ë„ìš°ê³  ì„¬ ë°”ë‹¥ì„ ë‘ê»ê²Œ ìŒ“ëŠ” ì¤‘... ğŸ„</div>
<div id="canvas-container"></div>
<div class="controls-info">í™”ë©´ì„ ë“œë˜ê·¸í•˜ì—¬ ë– ìˆëŠ” ê²¨ìš¸ ì„¬ì„ ê°ìƒí•˜ì„¸ìš”</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- ì„¤ì • ë³€ìˆ˜ ---
    const CONFIG = {
        snowCount: 2000,
        houseCount: 12,
        treeCount: 50,
        villagerCount: 12,
        sceneColor: 0x050510,
        fogColor: 0x050510,   
        islandRadius: 130,
        skySize: 4000
    };

    const container = document.getElementById('canvas-container');
    const loading = document.getElementById('loading');

    // ì”¬ ìƒì„±
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(CONFIG.sceneColor);
    scene.fog = new THREE.FogExp2(0x101025, 0.0015);

    // ì¹´ë©”ë¼ ì„¤ì •
    const aspect = container.clientWidth / container.clientHeight;
    const d = 100;
    const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 10000);
    camera.position.set(100, 80, 100); 
    camera.lookAt(scene.position);

    // ë Œë”ëŸ¬
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    // ê°ë„ ì œí•œ ìœ ì§€ (ìš”ì²­í•˜ì‹  ëŒ€ë¡œ ìˆ˜ì •í•˜ì§€ ì•ŠìŒ)
    controls.maxPolarAngle = Math.PI / 1.8; 
    controls.minZoom = 0.4;
    controls.maxZoom = 2.5;

    // --- ì¡°ëª… ---
    function setupLighting() {
        const ambientLight = new THREE.HemisphereLight(0xeef0ff, 0x050510, 0.4);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(-80, 100, -60);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        dirLight.shadow.camera.left = -150;
        dirLight.shadow.camera.right = 150;
        dirLight.shadow.camera.top = 150;
        dirLight.shadow.camera.bottom = -150;
        scene.add(dirLight);

        const centerLight = new THREE.PointLight(0xffaa00, 2.0, 80);
        centerLight.position.set(0, 20, 0);
        scene.add(centerLight);
    }
    setupLighting();

    // --- ì¬ì§ˆ ---
    const materials = {
        snow: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 }),
        ice: new THREE.MeshStandardMaterial({ color: 0xcfefff, roughness: 0.5, metalness: 0.1, flatShading: true }), // ë°”ìœ„ ì§ˆê° ì¡°ì •
        wood: new THREE.MeshStandardMaterial({ color: 0x8d6e63, roughness: 1.0 }),
        darkWood: new THREE.MeshStandardMaterial({ color: 0x4e342e, roughness: 1.0 }),
        leaf: new THREE.MeshStandardMaterial({ color: 0x1b5e20, roughness: 0.8, flatShading: true }),
        glowYellow: new THREE.MeshStandardMaterial({ 
            color: 0xffd54f, emissive: 0xffa000, emissiveIntensity: 4 
        }),
        gold: new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 }),
        red: new THREE.MeshStandardMaterial({ color: 0xd32f2f, roughness: 0.3, metalness: 0.1 }),
        silver: new THREE.MeshStandardMaterial({ color: 0xe0e0e0, metalness: 0.9, roughness: 0.1 }),
        blue: new THREE.MeshStandardMaterial({ color: 0x1976d2, roughness: 0.3, metalness: 0.1 }),
        lampPost: new THREE.MeshStandardMaterial({ color: 0x212121, metalness: 0.5, roughness: 0.5 }),
        moon: new THREE.MeshBasicMaterial({ color: 0xffffdd, fog: false }),
        star: new THREE.PointsMaterial({ color: 0xffffff, size: 1, sizeAttenuation: false, fog: false })
    };

    // --- [ìˆ˜ì •] ë‘íˆ¼í•˜ê³  ë¶ˆê·œì¹™í•œ ë–  ìˆëŠ” ì„¬ ---
    function createFloatingIsland() {
        const islandGroup = new THREE.Group();
        
        // 1. ì¤‘ì‹¬ë¶€ ìƒë‹¨ (ëˆˆ ë®ì¸ í‰í‰í•œ ë¶€ë¶„)
        const mainGeo = new THREE.CylinderGeometry(CONFIG.islandRadius * 0.8, CONFIG.islandRadius * 0.85, 5, 32);
        const mainMesh = new THREE.Mesh(mainGeo, materials.snow);
        mainMesh.position.y = -2.5;
        mainMesh.receiveShadow = true;
        islandGroup.add(mainMesh);

        // 2. [ì‹ ê·œ] ì¤‘ì‹¬ë¶€ í•˜ë‹¨ì„ ì±„ì›Œì£¼ëŠ” ê±°ëŒ€í•œ ë°”ìœ„ ë©ì–´ë¦¬ë“¤ (ê¸°ë°˜ ê³µì‚¬)
        for(let i=0; i<6; i++) {
            // ì„¬ ë°˜ì§€ë¦„ì˜ 30%~50% í¬ê¸°ì˜ ê±°ëŒ€í•œ ë©ì–´ë¦¬
            const scale = CONFIG.islandRadius * (0.3 + Math.random() * 0.2);
            const geo = new THREE.DodecahedronGeometry(scale, 0);
            const mesh = new THREE.Mesh(geo, materials.ice);
            
            // ì¤‘ì‹¬ë¶€ ê·¼ì²˜ ê¹Šì€ ê³³ì— ë°°ì¹˜í•˜ì—¬ ë¶€í”¼ê° í˜•ì„±
            mesh.position.set(
                (Math.random() - 0.5) * 40, // ì¤‘ì‹¬ì—ì„œ ì•½ê°„ ë²—ì–´ë‚œ ìœ„ì¹˜
                -scale * 0.8 - Math.random() * 20, // ê¹Šì´ ì„¤ì • (ìƒë‹¨ ë°”ë¡œ ì•„ë˜ë¶€í„° ê¹Šê²Œ)
                (Math.random() - 0.5) * 40
            );
            mesh.rotation.set(Math.random(), Math.random(), Math.random());
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            islandGroup.add(mesh);
        }

        // 3. [ìˆ˜ì •] ë¶ˆê·œì¹™í•œ í…Œë‘ë¦¬ ë° í•˜ë‹¨ë¶€ ì±„ì›€ (ê°œìˆ˜ ëŠ˜ë¦¬ê³  ê¹Šì´ í™•ì¥)
        const numRocks = 80; // ë°”ìœ„ ê°œìˆ˜ ì¦ê°€ (40 -> 80)
        for (let i = 0; i < numRocks; i++) {
            const angle = (i / numRocks) * Math.PI * 2;
            // ë°˜ì§€ë¦„ ë‹¤ì–‘ì„± ì¦ê°€
            const radius = CONFIG.islandRadius * (0.7 + Math.random() * 0.4);
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            // [í•µì‹¬ ìˆ˜ì •] ê¹Šì´ ë²”ìœ„ë¥¼ í›¨ì”¬ ê¹Šê²Œ í™•ì¥ (-5 ~ -85)
            const y = -5 - Math.random() * 80;
            // ìŠ¤ì¼€ì¼ë„ ë” ë‹¤ì–‘í•˜ê²Œ
            const scale = 15 + Math.random() * 35;

            const geo = new THREE.DodecahedronGeometry(scale, 0);
            const mesh = new THREE.Mesh(geo, materials.ice);
            mesh.position.set(x, y, z);
            // ëœë¤ íšŒì „ìœ¼ë¡œ ë¶ˆê·œì¹™í•¨ ê°•ì¡°
            mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            islandGroup.add(mesh);

            // í…Œë‘ë¦¬ ë¶€ë¶„ ìƒë‹¨ì— ëˆˆ ì¡°ê¸ˆ ë®ê¸° (ë„ˆë¬´ ê¹Šì§€ ì•Šì€ ê²ƒë“¤ë§Œ)
            if (y > -25) {
                const snowGeo = new THREE.DodecahedronGeometry(scale * 0.95, 0);
                const snowMesh = new THREE.Mesh(snowGeo, materials.snow);
                // ë°”ìœ„ ìœ„ì— ì‚´ì§ ì–¹íˆë„ë¡ ìœ„ì¹˜ ì¡°ì •
                snowMesh.position.set(x, y + scale * 0.4, z);
                snowMesh.rotation.copy(mesh.rotation);
                snowMesh.receiveShadow = true;
                islandGroup.add(snowMesh);
            }
        }
        scene.add(islandGroup);
    }
    createFloatingIsland();

    // --- ë°¤í•˜ëŠ˜ (ë‹¬ê³¼ ë³„) ---
    function createNightSky() {
        // 1. ê·¸ë¼ë°ì´ì…˜ í•˜ëŠ˜
        const skyGeo = new THREE.SphereGeometry(CONFIG.skySize, 64, 64);
        const count = skyGeo.attributes.position.count;
        const colors = [];
        const colorTop = new THREE.Color(0x020205);
        const colorMid = new THREE.Color(0x1a1a40);
        const colorBot = new THREE.Color(0x050510);

        for(let i = 0; i < count; i++) {
            const y = skyGeo.attributes.position.getY(i);
            const r = CONFIG.skySize;
            const t = (y / r + 1) / 2; 
            let c = new THREE.Color();
            if(t > 0.5) {
                c.copy(colorMid).lerp(colorTop, Math.pow((t - 0.5) * 2, 0.5));
            } else {
                c.copy(colorBot).lerp(colorMid, t * 2);
            }
            colors.push(c.r, c.g, c.b);
        }
        skyGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        const skyMat = new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.BackSide, fog: false });
        const skyDome = new THREE.Mesh(skyGeo, skyMat);
        scene.add(skyDome);

        // 2. ë‹¬ (Moon)
        const moonGroup = new THREE.Group();
        const moonMesh = new THREE.Mesh(new THREE.SphereGeometry(40, 32, 32), materials.moon);
        const glowGeo = new THREE.CircleGeometry(60, 32);
        const glowMat = new THREE.MeshBasicMaterial({ color: 0xffffaa, transparent: true, opacity: 0.2, side: THREE.DoubleSide, fog: false });
        const glowMesh = new THREE.Mesh(glowGeo, glowMat);
        glowMesh.lookAt(camera.position); 
        moonGroup.add(moonMesh);
        moonGroup.add(glowMesh);
        moonGroup.position.set(500, 800, -1000); 
        scene.add(moonGroup);

        // 3. ë³„ (Stars)
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<3000; i++) {
            const r = CONFIG.skySize * 0.9;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            starPos.push(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.cos(phi),
                r * Math.sin(phi) * Math.sin(theta)
            );
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        const stars = new THREE.Points(starGeo, materials.star);
        scene.add(stars);
    }

    // --- ëˆˆì†¡ì´ ---
    let snowSystem;
    function createSnow() {
        const geo = new THREE.BufferGeometry();
        const positions = [];
        const velocities = [];
        const range = CONFIG.islandRadius * 2.5;

        for (let i = 0; i < CONFIG.snowCount; i++) {
            positions.push(
                (Math.random() - 0.5) * range,
                Math.random() * 200,
                (Math.random() - 0.5) * range
            );
            velocities.push(Math.random() * 0.4 + 0.1);
        }

        geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
        grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 32, 32);

        const mat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 1.5,
            map: new THREE.CanvasTexture(canvas),
            transparent: true,
            opacity: 0.8,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        snowSystem = new THREE.Points(geo, mat);
        snowSystem.userData = { velocities: velocities };
        scene.add(snowSystem);
    }

    // --- (ì´í•˜ ì˜¤ë¸Œì íŠ¸ ìƒì„± í•¨ìˆ˜ë“¤ì€ ê¸°ì¡´ ìœ ì§€) ---
    // ì†Œë‚˜ë¬´
    function createPineTree(x, z, scale = 1) {
        const group = new THREE.Group();
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5 * scale, 1 * scale, 3 * scale, 6), materials.darkWood);
        trunk.position.y = 1.5 * scale;
        trunk.castShadow = true;
        group.add(trunk);
        for(let i=0; i<3; i++) {
            const size = (2.5 - i * 0.5) * scale;
            const y = (3 + i * 2) * scale;
            const cone = new THREE.Mesh(new THREE.ConeGeometry(size, 3 * scale, 7), materials.leaf);
            cone.position.y = y;
            cone.castShadow = true;
            cone.receiveShadow = true;
            group.add(cone);
            const snowCap = new THREE.Mesh(new THREE.ConeGeometry(size * 0.9, 1 * scale, 7), materials.snow);
            snowCap.position.y = y - 0.5 * scale;
            snowCap.rotation.y = Math.random();
            group.add(snowCap);
        }
        group.position.set(x, 0, z);
        group.rotation.y = Math.random() * Math.PI * 2;
        const randScale = 0.8 + Math.random() * 0.4;
        group.scale.set(randScale, randScale, randScale);
        scene.add(group);
    }

    // ê°€ë¡œë“±
    function createLamp(x, z) {
        const group = new THREE.Group();
        const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 8, 6), materials.lampPost);
        pole.position.y = 4;
        pole.castShadow = true;
        group.add(pole);
        const head = new THREE.Mesh(new THREE.DodecahedronGeometry(0.8), materials.glowYellow);
        head.position.y = 8;
        group.add(head);
        const light = new THREE.PointLight(0xffaa00, 1.5, 15);
        light.position.y = 8;
        group.add(light);
        group.position.set(x, 0, z);
        scene.add(group);
    }

    // ëˆˆì‚¬ëŒ
    function createSnowman(x, z) {
        const group = new THREE.Group();
        const bottom = new THREE.Mesh(new THREE.SphereGeometry(1.5, 12, 12), materials.snow);
        bottom.position.y = 1.2;
        bottom.castShadow = true;
        const top = new THREE.Mesh(new THREE.SphereGeometry(1.0, 12, 12), materials.snow);
        top.position.y = 3.2;
        top.castShadow = true;
        const nose = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.8, 8), materials.red);
        nose.geometry.rotateX(Math.PI / 2);
        nose.position.set(0, 3.2, 0.9);
        const hat = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 1, 8), materials.lampPost);
        hat.position.set(0, 4.2, 0);
        group.add(bottom, top, nose, hat);
        group.position.set(x, 0, z);
        group.rotation.y = (Math.random() - 0.5) * 1;
        scene.add(group);
    }

    // ì„ ë¬¼
    function createGift(x, z) {
        const size = 1 + Math.random();
        const box = new THREE.Mesh(new THREE.BoxGeometry(size, size, size), new THREE.MeshStandardMaterial({ color: Math.random() > 0.5 ? 0xd32f2f : 0x1976d2, roughness: 0.4 }));
        box.position.set(x, size/2, z);
        box.rotation.y = Math.random();
        box.castShadow = true;
        scene.add(box);
    }

    // ì§‘
    function createHouse(x, z, angle) {
        const group = new THREE.Group();
        const w = 7 + Math.random() * 3;
        const d = 7 + Math.random() * 3;
        const h = 6 + Math.random() * 3;
        const walls = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), Math.random() > 0.5 ? materials.wood : materials.darkWood);
        walls.position.y = h/2;
        walls.castShadow = true;
        walls.receiveShadow = true;
        group.add(walls);
        const roofH = 4;
        const roof = new THREE.Mesh(new THREE.ConeGeometry(Math.max(w,d)*0.8, roofH, 4), materials.snow);
        roof.position.y = h + roofH/2;
        roof.rotation.y = Math.PI/4;
        roof.scale.set(1, 1, w > d ? 0.6 : 1.4);
        roof.castShadow = true;
        group.add(roof);
        const win = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 1.2), materials.glowYellow);
        win.position.set(0, h/2, d/2 + 0.05);
        group.add(win);
        const door = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 3), materials.darkWood);
        door.position.set(w/4, 1.5, d/2 + 0.06);
        group.add(door);
        group.position.set(x, 0, z);
        group.rotation.y = angle;
        scene.add(group);
    }

    // ë©”ì¸ íŠ¸ë¦¬
    const ornaments = [];
    let fairyLightsSystem;
    function createMainTree() {
        const group = new THREE.Group();
        const levels = 7;
        const maxRadius = 10;
        const treeHeight = 35;
        for(let i=0; i<levels; i++) {
            const ratio = i / levels;
            const r = maxRadius * (1 - ratio * 0.8); 
            const y = 3 + i * 4;
            const cone = new THREE.Mesh(new THREE.ConeGeometry(r, 8, 10), materials.leaf);
            cone.position.y = y;
            cone.castShadow = true;
            cone.receiveShadow = true;
            group.add(cone);
            if(i < levels-1) {
                const snowRing = new THREE.Mesh(new THREE.TorusGeometry(r * 0.9, 0.2, 2, 10), materials.snow);
                snowRing.position.y = y - 3.5;
                snowRing.rotation.x = Math.PI / 2;
                group.add(snowRing);
            }
        }
        for(let i=0; i<levels; i++) {
            const r = maxRadius * (1 - i / levels * 0.8);
            const y = 3 + i * 4;
            const count = 10 - i; 
            if(count < 3) continue;
            for(let j=0; j<count; j++) {
                const angle = (j / count) * Math.PI * 2 + (i * 0.5);
                const ox = Math.cos(angle) * r * 0.85; 
                const oz = Math.sin(angle) * r * 0.85;
                const rand = Math.random();
                let mat = materials.red;
                if(rand > 0.75) mat = materials.gold;
                else if(rand > 0.5) mat = materials.silver;
                else if(rand > 0.25) mat = materials.blue;
                const size = 0.4 + Math.random() * 0.2;
                const ball = new THREE.Mesh(new THREE.SphereGeometry(size, 8, 8), mat);
                ball.position.set(ox, y - 3, oz);
                group.add(ball);
                if(Math.random() > 0.8) {
                    ball.material = materials.glowYellow;
                    ornaments.push({ mesh: ball, offset: Math.random() * 10 });
                }
            }
        }
        const points = [];
        const loops = 5;
        const hStart = 3;
        const hEnd = 30;
        for(let i = 0; i <= 150; i++) {
            const t = i / 150;
            const angle = t * Math.PI * 2 * loops;
            const y = hStart + t * (hEnd - hStart);
            const currentR = maxRadius * (1 - t * 0.9) + 0.2;
            points.push(new THREE.Vector3(Math.cos(angle) * currentR, y, Math.sin(angle) * currentR));
        }
        const ribbon = new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(points), 100, 0.3, 8, false), materials.gold);
        ribbon.castShadow = true;
        group.add(ribbon);
        const fairyGeo = new THREE.BufferGeometry();
        const fairyPos = [];
        const fairyCount = 300;
        for(let i=0; i<fairyCount; i++) {
            const t = i / fairyCount;
            const angle = t * Math.PI * 2 * 9 + Math.random(); 
            const y = hStart + t * (hEnd - hStart) + (Math.random()-0.5);
            const r = (maxRadius * (1 - t * 0.9)) + 0.4 + (Math.random() * 0.5);
            fairyPos.push(Math.cos(angle) * r, y, Math.sin(angle) * r);
        }
        fairyGeo.setAttribute('position', new THREE.Float32BufferAttribute(fairyPos, 3));
        const fairyMat = new THREE.PointsMaterial({ color: 0xffe082, size: 0.6, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending });
        fairyLightsSystem = new THREE.Points(fairyGeo, fairyMat);
        group.add(fairyLightsSystem);
        const star = new THREE.Mesh(new THREE.OctahedronGeometry(2.5, 0), materials.glowYellow);
        star.position.y = 32;
        star.userData = { rotationSpeed: 0.02 }; 
        group.add(star);
        ornaments.push({ mesh: star, isStar: true });
        scene.add(group);
    }

    // ì°ë§¤
    let sleighGroup;
    function createSleigh() {
        sleighGroup = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(4, 2, 6), materials.red);
        sleighGroup.add(body);
        const light = new THREE.PointLight(0xffffff, 1, 10);
        light.position.set(0, 1, 0);
        sleighGroup.add(light);
        for(let i=0; i<4; i++) {
            const deer = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 2), materials.wood);
            deer.position.set(i%2===0 ? -1.5 : 1.5, -0.5, 5 + Math.floor(i/2)*3);
            if(i >= 2) {
                const nose = new THREE.Mesh(new THREE.SphereGeometry(0.3), materials.glowYellow);
                nose.position.set(0, 0.5, 1);
                deer.add(nose);
            }
            sleighGroup.add(deer);
        }
        scene.add(sleighGroup);
    }

    // ì£¼ë¯¼
    const villagers = [];
    function createVillagers() {
        const geo = new THREE.CapsuleGeometry(0.4, 0.8, 4, 8);
        const headGeo = new THREE.SphereGeometry(0.35);
        for(let i=0; i<CONFIG.villagerCount; i++) {
            const group = new THREE.Group();
            const color = new THREE.Color().setHSL(Math.random(), 0.8, 0.4);
            const mat = new THREE.MeshStandardMaterial({ color: color });
            const body = new THREE.Mesh(geo, mat);
            body.position.y = 0.8;
            body.castShadow = true;
            const head = new THREE.Mesh(headGeo, materials.wood);
            head.position.y = 1.6;
            group.add(body, head);
            const angle = Math.random() * Math.PI * 2;
            const dist = 10 + Math.random() * (CONFIG.islandRadius * 0.4);
            group.position.set(Math.cos(angle)*dist, 0, Math.sin(angle)*dist);
            scene.add(group);
            villagers.push({ mesh: group, angle: angle, dist: dist, speed: 0.003 + Math.random() * 0.004, hopOffset: Math.random() * Math.PI });
        }
    }

    function initWorld() {
        createNightSky();
        createSnow();
        createMainTree();
        createSleigh();
        createVillagers();

        const islandLimit = CONFIG.islandRadius * 0.8;

        // 1. ì§‘ ë°°ì¹˜
        for(let i=0; i<CONFIG.houseCount; i++) {
            const angle = (i / CONFIG.houseCount) * Math.PI * 2 + (Math.random()*0.2);
            const dist = 35 + Math.random() * 10;
            if (dist < islandLimit) {
                createHouse(Math.cos(angle)*dist, Math.sin(angle)*dist, -angle + Math.PI/2);
                if(Math.random() > 0.3) createLamp(Math.cos(angle)*(dist+6), Math.sin(angle)*(dist+6));
                if(Math.random() > 0.5) createGift(Math.cos(angle)*(dist-4), Math.sin(angle)*(dist-4));
            }
        }

        // 2. ìˆ² ë°°ì¹˜
        for(let i=0; i<CONFIG.treeCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 50 + Math.random() * 60; 
            if (dist < islandLimit) {
                createPineTree(Math.cos(angle)*dist, Math.sin(angle)*dist, 1 + Math.random()*0.5);
            }
        }

        // 3. ëˆˆì‚¬ëŒ
        for(let i=0; i<5; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 20 + Math.random() * 20;
            if (dist < islandLimit) {
                createSnowman(Math.cos(angle)*dist, Math.sin(angle)*dist);
            }
        }

        loading.style.opacity = 0;
        setTimeout(() => loading.remove(), 500);
    }
    
    initWorld();

    // --- ì• ë‹ˆë©”ì´ì…˜ ---
    const clock = new THREE.Clock();
    
    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();

        controls.update();

        // ëˆˆ
        if(snowSystem) {
            const pos = snowSystem.geometry.attributes.position.array;
            const vel = snowSystem.userData.velocities;
            for(let i=0; i<CONFIG.snowCount; i++) {
                pos[i*3 + 1] -= vel[i];
                // ëˆˆì´ ì„¬ì˜ ê°€ì¥ ê¹Šì€ ë°”ë‹¥ë³´ë‹¤ ë” ì•„ë˜ë¡œ ë–¨ì–´ì§€ë©´ ì¬ì‚¬ìš©
                if(pos[i*3+1] < -100) { 
                    pos[i*3+1] = 150;
                    pos[i*3] = (Math.random()-0.5) * CONFIG.islandRadius * 2.5;
                    pos[i*3+2] = (Math.random()-0.5) * CONFIG.islandRadius * 2.5;
                }
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
            snowSystem.rotation.y = Math.sin(time * 0.1) * 0.1;
        }

        if(sleighGroup) {
            const r = 50;
            const h = 40;
            sleighGroup.position.x = Math.sin(time*0.3) * r;
            sleighGroup.position.z = Math.cos(time*0.3) * r;
            sleighGroup.position.y = h + Math.sin(time*0.8)*5;
            sleighGroup.lookAt(Math.sin(time*0.3 + 0.1) * r, h, Math.cos(time*0.3 + 0.1) * r);
        }

        ornaments.forEach(obj => {
            if(obj.isStar) {
                if (obj.mesh.userData && obj.mesh.userData.rotationSpeed) {
                    obj.mesh.rotation.y += obj.mesh.userData.rotationSpeed;
                }
                const s = 1 + Math.sin(time*2)*0.2;
                obj.mesh.scale.set(s,s,s);
            } else {
                obj.mesh.material.emissiveIntensity = 1.5 + Math.sin(time*3 + obj.offset);
            }
        });

        if(fairyLightsSystem) {
            fairyLightsSystem.rotation.y = time * 0.05;
            const blink = 0.7 + Math.sin(time * 3) * 0.3;
            fairyLightsSystem.material.opacity = blink;
        }

        villagers.forEach(v => {
            v.angle += v.speed;
            v.mesh.position.x = Math.cos(v.angle) * v.dist;
            v.mesh.position.z = Math.sin(v.angle) * v.dist;
            v.mesh.rotation.y = -v.angle;
            v.mesh.position.y = Math.abs(Math.sin(time*8 + v.hopOffset)) * 0.6;
        });

        renderer.render(scene, camera);
    }
    
    animate();

    window.addEventListener('resize', () => {
        const aspect = window.innerWidth / window.innerHeight;
        camera.left = -d * aspect;
        camera.right = d * aspect;
        camera.top = d;
        camera.bottom = -d;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
