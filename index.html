<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ultimate Christmas Tree Village</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a2e;
            font-family: 'Noto Sans KR', sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            font-size: 1.2rem;
            pointer-events: none;
            transition: opacity 0.5s;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            text-align: center;
        }
        .controls-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.9rem;
            pointer-events: none;
            text-shadow: 0 1px 5px rgba(0,0,0,0.8);
            text-align: center;
        }
    </style>
</head>
<body>

<div id="loading">ğŸ„ íŠ¸ë¦¬ì— ìš”ì • ì¡°ëª…ì„ ê°ëŠ” ì¤‘... ğŸ„</div>
<div id="canvas-container"></div>
<div class="controls-info">í™”ë©´ì„ ë“œë˜ê·¸í•˜ì—¬ ë§ˆì„ ë‘˜ëŸ¬ë³´ê¸°</div>

<!-- Three.js CDN -->
<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- ì„¤ì • ë³€ìˆ˜ ---
    const CONFIG = {
        snowCount: 2500,
        houseCount: 12,
        treeCount: 60,
        villagerCount: 15,
        sceneColor: 0x151525, // ë” ê¹Šì€ ë°¤ìƒ‰
        fogColor: 0x151525,
        shadowMapSize: 2048,
        groundSize: 400
    };

    const container = document.getElementById('canvas-container');
    const loading = document.getElementById('loading');

    // ì”¬ ìƒì„±
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(CONFIG.sceneColor);
    scene.fog = new THREE.FogExp2(CONFIG.fogColor, 0.002); 

    // ì¹´ë©”ë¼
    const aspect = container.clientWidth / container.clientHeight;
    const d = 65;
    const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
    camera.position.set(100, 80, 100); 
    camera.lookAt(scene.position);

    // ë Œë”ëŸ¬
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.4; // ë°ê¸° ì¦ê°€
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 2 - 0.1;
    controls.minZoom = 0.4;
    controls.maxZoom = 2.5;

    // --- ì¡°ëª… ---
    function setupLighting() {
        const ambientLight = new THREE.HemisphereLight(0xffffff, 0x4444aa, 0.5);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(-80, 120, -60);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        dirLight.shadow.camera.left = -150;
        dirLight.shadow.camera.right = 150;
        dirLight.shadow.camera.top = 150;
        dirLight.shadow.camera.bottom = -150;
        scene.add(dirLight);

        // ì¤‘ì•™ íŠ¸ë¦¬ë¥¼ ìœ„í•œ ê°•ë ¥í•œ í¬ì¸íŠ¸ ë¼ì´íŠ¸ (ë”°ëœ»í•œ ìƒ‰)
        const centerLight = new THREE.PointLight(0xffaa00, 2.5, 60);
        centerLight.position.set(0, 15, 0);
        scene.add(centerLight);
        
        // íŠ¸ë¦¬ ìƒë‹¨ë¶€ ë³´ì¡° ì¡°ëª… (ì•½ê°„ í‘¸ë¥¸ë¹›ìœ¼ë¡œ ì‹ ë¹„ê°)
        const topLight = new THREE.PointLight(0x88ccff, 1.0, 40);
        topLight.position.set(0, 30, 0);
        scene.add(topLight);
    }
    setupLighting();

    // --- ì¬ì§ˆ ---
    const materials = {
        snow: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 }),
        wood: new THREE.MeshStandardMaterial({ color: 0x8d6e63, roughness: 1.0 }),
        darkWood: new THREE.MeshStandardMaterial({ color: 0x4e342e, roughness: 1.0 }),
        leaf: new THREE.MeshStandardMaterial({ color: 0x1b5e20, roughness: 0.8, flatShading: true }),
        glowYellow: new THREE.MeshStandardMaterial({ 
            color: 0xffd54f, emissive: 0xffa000, emissiveIntensity: 4 
        }),
        glowWhite: new THREE.MeshStandardMaterial({ 
            color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 2 
        }),
        gold: new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 }),
        red: new THREE.MeshStandardMaterial({ color: 0xd32f2f, roughness: 0.3, metalness: 0.1 }),
        blue: new THREE.MeshStandardMaterial({ color: 0x1976d2, roughness: 0.3, metalness: 0.1 }),
        silver: new THREE.MeshStandardMaterial({ color: 0xe0e0e0, metalness: 0.9, roughness: 0.1 }),
        lampPost: new THREE.MeshStandardMaterial({ color: 0x212121, metalness: 0.5, roughness: 0.5 })
    };

    // --- ë°”ë‹¥ ---
    const ground = new THREE.Mesh(
        new THREE.CylinderGeometry(CONFIG.groundSize, CONFIG.groundSize, 10, 64),
        materials.snow
    );
    ground.position.y = -5;
    ground.receiveShadow = true;
    scene.add(ground);

    // --- ëˆˆì†¡ì´ ---
    let snowSystem;
    function createSnow() {
        const geo = new THREE.BufferGeometry();
        const positions = [];
        const velocities = [];
        const range = 400;

        for (let i = 0; i < CONFIG.snowCount; i++) {
            positions.push(
                (Math.random() - 0.5) * range,
                Math.random() * 150,
                (Math.random() - 0.5) * range
            );
            velocities.push(Math.random() * 0.3 + 0.1);
        }

        geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
        grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 32, 32);

        const mat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 1.2,
            map: new THREE.CanvasTexture(canvas),
            transparent: true,
            opacity: 0.9,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        snowSystem = new THREE.Points(geo, mat);
        snowSystem.userData = { velocities: velocities };
        scene.add(snowSystem);
    }

    // --- ì†Œë‚˜ë¬´ ---
    function createPineTree(x, z, scale = 1) {
        const group = new THREE.Group();
        
        const trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.5 * scale, 1 * scale, 3 * scale, 6),
            materials.darkWood
        );
        trunk.position.y = 1.5 * scale;
        trunk.castShadow = true;
        group.add(trunk);

        for(let i=0; i<3; i++) {
            const size = (2.5 - i * 0.5) * scale;
            const y = (3 + i * 2) * scale;
            const cone = new THREE.Mesh(
                new THREE.ConeGeometry(size, 3 * scale, 7),
                materials.leaf
            );
            cone.position.y = y;
            cone.castShadow = true;
            cone.receiveShadow = true;
            group.add(cone);

            const snowCap = new THREE.Mesh(
                new THREE.ConeGeometry(size * 0.9, 1 * scale, 7),
                materials.snow
            );
            snowCap.position.y = y - 0.5 * scale;
            snowCap.rotation.y = Math.random();
            group.add(snowCap);
        }

        group.position.set(x, 0, z);
        group.rotation.y = Math.random() * Math.PI * 2;
        const randScale = 0.8 + Math.random() * 0.4;
        group.scale.set(randScale, randScale, randScale);
        scene.add(group);
    }

    // --- ê°€ë¡œë“± ---
    function createLamp(x, z) {
        const group = new THREE.Group();
        const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 8, 6), materials.lampPost);
        pole.position.y = 4;
        pole.castShadow = true;
        group.add(pole);

        const head = new THREE.Mesh(new THREE.DodecahedronGeometry(0.8), materials.glowYellow);
        head.position.y = 8;
        group.add(head);

        const light = new THREE.PointLight(0xffaa00, 1.5, 15);
        light.position.y = 8;
        group.add(light);

        group.position.set(x, 0, z);
        scene.add(group);
    }

    // --- ëˆˆì‚¬ëŒ ---
    function createSnowman(x, z) {
        const group = new THREE.Group();
        
        const bottom = new THREE.Mesh(new THREE.SphereGeometry(1.5, 12, 12), materials.snow);
        bottom.position.y = 1.2;
        bottom.castShadow = true;
        
        const top = new THREE.Mesh(new THREE.SphereGeometry(1.0, 12, 12), materials.snow);
        top.position.y = 3.2;
        top.castShadow = true;

        const nose = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.8, 8), materials.red);
        nose.geometry.rotateX(Math.PI / 2);
        nose.position.set(0, 3.2, 0.9);

        const hat = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 1, 8), materials.lampPost);
        hat.position.set(0, 4.2, 0);

        group.add(bottom, top, nose, hat);
        group.position.set(x, 0, z);
        group.rotation.y = (Math.random() - 0.5) * 1;
        scene.add(group);
    }

    // --- ì„ ë¬¼ ---
    function createGift(x, z) {
        const size = 1 + Math.random();
        const box = new THREE.Mesh(
            new THREE.BoxGeometry(size, size, size),
            new THREE.MeshStandardMaterial({ 
                color: Math.random() > 0.5 ? 0xd32f2f : 0x1976d2,
                roughness: 0.4
            })
        );
        box.position.set(x, size/2, z);
        box.rotation.y = Math.random();
        box.castShadow = true;
        scene.add(box);
    }

    // --- ì§‘ ---
    function createHouse(x, z, angle) {
        const group = new THREE.Group();
        const w = 7 + Math.random() * 3;
        const d = 7 + Math.random() * 3;
        const h = 6 + Math.random() * 3;

        const walls = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            Math.random() > 0.5 ? materials.wood : materials.darkWood
        );
        walls.position.y = h/2;
        walls.castShadow = true;
        walls.receiveShadow = true;
        group.add(walls);

        const roofH = 4;
        const roof = new THREE.Mesh(
            new THREE.ConeGeometry(Math.max(w,d)*0.8, roofH, 4),
            materials.snow
        );
        roof.position.y = h + roofH/2;
        roof.rotation.y = Math.PI/4;
        roof.scale.set(1, 1, w > d ? 0.6 : 1.4);
        roof.castShadow = true;
        group.add(roof);

        const win = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 1.2), materials.glowYellow);
        win.position.set(0, h/2, d/2 + 0.05);
        group.add(win);
        
        const door = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 3), materials.darkWood);
        door.position.set(w/4, 1.5, d/2 + 0.06);
        group.add(door);

        group.position.set(x, 0, z);
        group.rotation.y = angle;
        scene.add(group);
    }

    // --- â˜… ë©”ì¸ íŠ¸ë¦¬ (ê·¹í•œ ì—…ê·¸ë ˆì´ë“œ) â˜… ---
    const ornaments = [];
    let fairyLightsSystem; // ë°˜ì§ì´ëŠ” ì „êµ¬ íŒŒí‹°í´ ì‹œìŠ¤í…œ

    function createMainTree() {
        const group = new THREE.Group();

        const levels = 7;
        const maxRadius = 10;
        const treeHeight = 35;

        // 1. ë‚˜ë¬´ ë³¸ì²´ + ëˆˆ ìŒ“ì„ íš¨ê³¼
        for(let i=0; i<levels; i++) {
            const ratio = i / levels;
            const r = maxRadius * (1 - ratio * 0.8); // ìœ„ë¡œ ê°ˆìˆ˜ë¡ ì¢ê²Œ
            const y = 3 + i * 4;
            
            const cone = new THREE.Mesh(
                new THREE.ConeGeometry(r, 8, 10),
                materials.leaf
            );
            cone.position.y = y;
            cone.castShadow = true;
            cone.receiveShadow = true;
            group.add(cone);

            // ì ëì— ëˆˆ ì‚´ì§ (ì‘ì€ í°ìƒ‰ ê³ ë¦¬ ëŠë‚Œ)
            if(i < levels-1) {
                const snowRing = new THREE.Mesh(
                    new THREE.TorusGeometry(r * 0.9, 0.2, 2, 10), // ë¡œìš°í´ë¦¬ ëˆˆ
                    materials.snow
                );
                snowRing.position.y = y - 3.5;
                snowRing.rotation.x = Math.PI / 2;
                group.add(snowRing);
            }
        }

        // 2. ì˜¤ë„ˆë¨¼íŠ¸ (ë³¼) - ë” ë§ì´, ë” ì´˜ì´˜íˆ
        for(let i=0; i<levels; i++) {
            const r = maxRadius * (1 - i / levels * 0.8);
            const y = 3 + i * 4;
            
            // ì¸µë§ˆë‹¤ ê°œìˆ˜ ë‹¤ë¥´ê²Œ
            const count = 10 - i; 
            if(count < 3) continue;

            for(let j=0; j<count; j++) {
                const angle = (j / count) * Math.PI * 2 + (i * 0.5);
                const ox = Math.cos(angle) * r * 0.85; // ë‚˜ë¬´ í‘œë©´ì— ê°€ê¹ê²Œ
                const oz = Math.sin(angle) * r * 0.85;

                const rand = Math.random();
                let mat = materials.red;
                if(rand > 0.75) mat = materials.gold;
                else if(rand > 0.5) mat = materials.silver;
                else if(rand > 0.25) mat = materials.blue;

                const size = 0.4 + Math.random() * 0.2;
                const ball = new THREE.Mesh(new THREE.SphereGeometry(size, 8, 8), mat);
                ball.position.set(ox, y - 3, oz);
                group.add(ball);

                // ë¹›ë‚˜ëŠ” ì˜¤ë„ˆë¨¼íŠ¸(ê°€ë”)
                if(Math.random() > 0.8) {
                    ball.material = materials.glowYellow;
                    ornaments.push({ mesh: ball, offset: Math.random() * 10 });
                }
            }
        }

        // 3. ë‚˜ì„ í˜• ë¦¬ë³¸ (í• ê°œì„ )
        const points = [];
        const loops = 5;
        const hStart = 3;
        const hEnd = 30;
        
        for(let i = 0; i <= 150; i++) {
            const t = i / 150;
            const angle = t * Math.PI * 2 * loops;
            const y = hStart + t * (hEnd - hStart);
            
            // ë‚˜ë¬´ ê¸°ìš¸ê¸°ì— ë§ì¶° ë°˜ì§€ë¦„ ê³„ì‚° (ì„ í˜• ë³´ê°„)
            const currentR = maxRadius * (1 - t * 0.9) + 0.2; // 0.2ëŠ” ì—¬ìœ ë¶„

            points.push(new THREE.Vector3(
                Math.cos(angle) * currentR,
                y,
                Math.sin(angle) * currentR
            ));
        }
        const ribbon = new THREE.Mesh(
            new THREE.TubeGeometry(new THREE.CatmullRomCurve3(points), 100, 0.3, 8, false),
            materials.gold
        );
        ribbon.castShadow = true;
        group.add(ribbon);

        // 4. ìš”ì • ì¡°ëª… (Fairy Lights) - íŒŒí‹°í´ ì‹œìŠ¤í…œ
        const fairyGeo = new THREE.BufferGeometry();
        const fairyPos = [];
        const fairyCount = 300; // 300ê°œì˜ ì‘ì€ ì „êµ¬

        for(let i=0; i<fairyCount; i++) {
            const t = i / fairyCount;
            // ë¦¬ë³¸ê³¼ ë°˜ëŒ€ ë°©í–¥ í˜¹ì€ ì—‡ê°ˆë¦¬ê²Œ ë‚˜ì„ í˜• ë°°ì¹˜ + ëœë¤ ë…¸ì´ì¦ˆ
            const angle = t * Math.PI * 2 * 9 + Math.random(); 
            const y = hStart + t * (hEnd - hStart) + (Math.random()-0.5);
            
            // ë‚˜ë¬´ í‘œë©´ë³´ë‹¤ ì•„ì£¼ ì‚´ì§ ë°–ìœ¼ë¡œ
            const r = (maxRadius * (1 - t * 0.9)) + 0.4 + (Math.random() * 0.5);

            fairyPos.push(
                Math.cos(angle) * r,
                y,
                Math.sin(angle) * r
            );
        }
        fairyGeo.setAttribute('position', new THREE.Float32BufferAttribute(fairyPos, 3));
        const fairyMat = new THREE.PointsMaterial({
            color: 0xffe082,
            size: 0.6,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending
        });
        fairyLightsSystem = new THREE.Points(fairyGeo, fairyMat);
        // ê¹œë¹¡ì„ì„ ìœ„í•´ ì €ì¥
        fairyLightsSystem.userData = { phases: new Float32Array(fairyCount).map(() => Math.random() * Math.PI * 2) };
        group.add(fairyLightsSystem);


        // 5. ê¼­ëŒ€ê¸° ë³„
        const star = new THREE.Mesh(
            new THREE.OctahedronGeometry(2.5, 0),
            materials.glowYellow
        );
        star.position.y = 32;
        star.userData = { rotationSpeed: 0.02 }; 
        group.add(star);
        ornaments.push({ mesh: star, isStar: true });

        scene.add(group);
    }

    // --- ë£¨ëŒí”„ ì°ë§¤ ---
    let sleighGroup;
    function createSleigh() {
        sleighGroup = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(4, 2, 6), materials.red);
        sleighGroup.add(body);
        
        const light = new THREE.PointLight(0xffffff, 1, 10);
        light.position.set(0, 1, 0);
        sleighGroup.add(light);

        for(let i=0; i<4; i++) {
            const deer = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 2), materials.wood);
            deer.position.set(i%2===0 ? -1.5 : 1.5, -0.5, 5 + Math.floor(i/2)*3);
            if(i >= 2) {
                const nose = new THREE.Mesh(new THREE.SphereGeometry(0.3), materials.glowYellow);
                nose.position.set(0, 0.5, 1);
                deer.add(nose);
            }
            sleighGroup.add(deer);
        }
        scene.add(sleighGroup);
    }

    // --- ì£¼ë¯¼ ---
    const villagers = [];
    function createVillagers() {
        const geo = new THREE.CapsuleGeometry(0.4, 0.8, 4, 8);
        const headGeo = new THREE.SphereGeometry(0.35);

        for(let i=0; i<CONFIG.villagerCount; i++) {
            const group = new THREE.Group();
            const color = new THREE.Color().setHSL(Math.random(), 0.8, 0.4);
            const mat = new THREE.MeshStandardMaterial({ color: color });
            
            const body = new THREE.Mesh(geo, mat);
            body.position.y = 0.8;
            body.castShadow = true;
            
            const head = new THREE.Mesh(headGeo, materials.wood);
            head.position.y = 1.6;
            
            group.add(body, head);
            
            const angle = Math.random() * Math.PI * 2;
            const dist = 15 + Math.random() * 20;
            group.position.set(Math.cos(angle)*dist, 0, Math.sin(angle)*dist);
            
            scene.add(group);
            
            villagers.push({
                mesh: group,
                angle: angle,
                dist: dist,
                speed: 0.003 + Math.random() * 0.004,
                hopOffset: Math.random() * Math.PI
            });
        }
    }

    // --- ì´ˆê¸°í™” ---
    function initWorld() {
        createSnow();
        createMainTree();
        createSleigh();
        createVillagers();

        // 1. ì§‘ ë°°ì¹˜
        for(let i=0; i<CONFIG.houseCount; i++) {
            const angle = (i / CONFIG.houseCount) * Math.PI * 2 + (Math.random()*0.2);
            const dist = 35 + Math.random() * 10;
            createHouse(Math.cos(angle)*dist, Math.sin(angle)*dist, -angle + Math.PI/2);
            
            if(Math.random() > 0.3) {
                createLamp(Math.cos(angle)*(dist+6), Math.sin(angle)*(dist+6));
            }
            if(Math.random() > 0.5) {
                createGift(Math.cos(angle)*(dist-4), Math.sin(angle)*(dist-4));
            }
        }

        // 2. ìˆ² ë°°ì¹˜
        for(let i=0; i<CONFIG.treeCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 55 + Math.random() * 60; 
            createPineTree(Math.cos(angle)*dist, Math.sin(angle)*dist, 1 + Math.random()*0.5);
        }

        // 3. ëˆˆì‚¬ëŒ
        for(let i=0; i<5; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 25 + Math.random() * 20;
            createSnowman(Math.cos(angle)*dist, Math.sin(angle)*dist);
        }

        loading.style.opacity = 0;
        setTimeout(() => loading.remove(), 500);
    }
    
    initWorld();

    // --- ì• ë‹ˆë©”ì´ì…˜ ---
    const clock = new THREE.Clock();
    
    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();

        controls.update();

        // ëˆˆ
        if(snowSystem) {
            const pos = snowSystem.geometry.attributes.position.array;
            const vel = snowSystem.userData.velocities;
            for(let i=0; i<CONFIG.snowCount; i++) {
                pos[i*3 + 1] -= vel[i];
                if(pos[i*3+1] < 0) {
                    pos[i*3+1] = 150;
                    pos[i*3] = (Math.random()-0.5) * 400;
                    pos[i*3+2] = (Math.random()-0.5) * 400;
                }
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
            snowSystem.rotation.y = Math.sin(time * 0.1) * 0.1;
        }

        // ì°ë§¤
        if(sleighGroup) {
            const r = 60;
            const h = 40;
            sleighGroup.position.x = Math.sin(time*0.3) * r;
            sleighGroup.position.z = Math.cos(time*0.3) * r;
            sleighGroup.position.y = h + Math.sin(time*0.8)*5;
            sleighGroup.lookAt(
                Math.sin(time*0.3 + 0.1) * r, 
                h, 
                Math.cos(time*0.3 + 0.1) * r
            );
        }

        // ì˜¤ë„ˆë¨¼íŠ¸
        ornaments.forEach(obj => {
            if(obj.isStar) {
                if (obj.mesh.userData && obj.mesh.userData.rotationSpeed) {
                    obj.mesh.rotation.y += obj.mesh.userData.rotationSpeed;
                }
                const s = 1 + Math.sin(time*2)*0.2;
                obj.mesh.scale.set(s,s,s);
            } else {
                obj.mesh.material.emissiveIntensity = 1.5 + Math.sin(time*3 + obj.offset);
            }
        });

        // ìš”ì • ì¡°ëª… (Fairy Lights) ë°˜ì§ì„
        if(fairyLightsSystem) {
            // ì „ì²´ì ìœ¼ë¡œ ì²œì²œíˆ íšŒì „
            fairyLightsSystem.rotation.y = time * 0.05;
            
            // materialì˜ íˆ¬ëª…ë„ë‚˜ í¬ê¸°ë¥¼ ì¡°ì ˆí•˜ëŠ” ê±´ draw call ë•Œë¬¸ì— ë³µì¡í•˜ë‹ˆ
            // ê°„ë‹¨í•˜ê²Œ ì „ì²´ ë°ê¸°ë¥¼ ì‚¬ì¸íŒŒë¡œ ì¡°ì ˆí•˜ê±°ë‚˜ (ì—¬ê¸°ì„  ìƒ‰ìƒìœ¼ë¡œ ë¯¸ì„¸ ì¡°ì •)
            const blink = 0.7 + Math.sin(time * 3) * 0.3;
            fairyLightsSystem.material.opacity = blink;
        }

        // ì£¼ë¯¼
        villagers.forEach(v => {
            v.angle += v.speed;
            v.mesh.position.x = Math.cos(v.angle) * v.dist;
            v.mesh.position.z = Math.sin(v.angle) * v.dist;
            v.mesh.rotation.y = -v.angle;
            v.mesh.position.y = Math.abs(Math.sin(time*8 + v.hopOffset)) * 0.6;
        });

        renderer.render(scene, camera);
    }
    
    animate();

    // ë¦¬ì‚¬ì´ì¦ˆ
    window.addEventListener('resize', () => {
        const aspect = window.innerWidth / window.innerHeight;
        camera.left = -d * aspect;
        camera.right = d * aspect;
        camera.top = d;
        camera.bottom = -d;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
