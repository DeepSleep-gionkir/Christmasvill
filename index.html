<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ultimate Christmas Tree Village</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0b1026; /* ê¸°ë³¸ ë°°ê²½ìƒ‰ì„ ë” ê¹Šì€ ë°¤ìƒ‰ìœ¼ë¡œ ë³€ê²½ */
            font-family: 'Noto Sans KR', sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            font-size: 1.2rem;
            pointer-events: none;
            transition: opacity 0.5s;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            text-align: center;
        }
        .controls-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.9rem;
            pointer-events: none;
            text-shadow: 0 1px 5px rgba(0,0,0,0.8);
            text-align: center;
        }
    </style>
</head>
<body>

<div id="loading">ğŸ„ íŠ¸ë¦¬ì— ìš”ì • ì¡°ëª…ì„ ê°ëŠ” ì¤‘... ğŸ„</div>
<div id="canvas-container"></div>
<div class="controls-info">í™”ë©´ì„ ë“œë˜ê·¸í•˜ì—¬ ë§ˆì„ ë‘˜ëŸ¬ë³´ê¸°</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- ì„¤ì • ë³€ìˆ˜ ---
    const CONFIG = {
        snowCount: 2500,
        houseCount: 12,
        treeCount: 60,
        villagerCount: 15,
        sceneColor: 0x0b1026, // ì•„ì£¼ ì–´ë‘ìš´ ë°¤í•˜ëŠ˜ìƒ‰
        fogColor: 0x151525,   
        shadowMapSize: 2048,
        groundSize: 5000,     // [ìˆ˜ì •] ë°”ë‹¥ í¬ê¸°ë¥¼ ëŒ€í­ ëŠ˜ë ¤ ê²€ì€ ê³µê°„ ì œê±°
        skySize: 4000         // [ì¶”ê°€] í•˜ëŠ˜ ë” í¬ê¸°
    };

    const container = document.getElementById('canvas-container');
    const loading = document.getElementById('loading');

    // ì”¬ ìƒì„±
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(CONFIG.sceneColor);
    // ì•ˆê°œ ê±°ë¦¬ë¥¼ ëŠ˜ë ¤ì„œ í•˜ëŠ˜ ê·¸ë¼ë°ì´ì…˜ì´ ë³´ì´ë„ë¡ ì¡°ì •
    scene.fog = new THREE.FogExp2(CONFIG.fogColor, 0.001); 

    // ì¹´ë©”ë¼ ì„¤ì • (Orthographic)
    const aspect = container.clientWidth / container.clientHeight;
    const d = 65;
    // [ìˆ˜ì •] far ê°’ì„ 10000ìœ¼ë¡œ ëŠ˜ë ¤ ê±°ëŒ€í•œ ë°”ë‹¥ê³¼ í•˜ëŠ˜ì´ ì˜ë¦¬ì§€ ì•Šê²Œ í•¨
    const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 10000);
    camera.position.set(100, 80, 100); 
    camera.lookAt(scene.position);

    // ë Œë”ëŸ¬
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.3;
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 2 - 0.05; // ë•… ë°‘ìœ¼ë¡œ ë‚´ë ¤ê°€ì§€ ì•Šë„ë¡ ì œí•œ
    controls.minZoom = 0.4;
    controls.maxZoom = 2.5;

    // --- ì¡°ëª… ---
    function setupLighting() {
        const ambientLight = new THREE.HemisphereLight(0xffffff, 0x2a2a35, 0.6); // í•˜ë‹¨ ìƒ‰ìƒì„ ì–´ë‘¡ê²Œ ì¡°ì •
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(-80, 120, -60);
        dirLight.castShadow = true;
        // ê·¸ë¦¼ì ë²”ìœ„ë„ ë„‰ë„‰í•˜ê²Œ
        dirLight.shadow.mapSize.set(2048, 2048);
        dirLight.shadow.camera.left = -200;
        dirLight.shadow.camera.right = 200;
        dirLight.shadow.camera.top = 200;
        dirLight.shadow.camera.bottom = -200;
        scene.add(dirLight);

        const centerLight = new THREE.PointLight(0xffaa00, 2.5, 60);
        centerLight.position.set(0, 15, 0);
        scene.add(centerLight);
        
        const topLight = new THREE.PointLight(0x88ccff, 1.0, 40);
        topLight.position.set(0, 30, 0);
        scene.add(topLight);
    }
    setupLighting();

    // --- ì¬ì§ˆ ---
    const materials = {
        snow: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 }),
        wood: new THREE.MeshStandardMaterial({ color: 0x8d6e63, roughness: 1.0 }),
        darkWood: new THREE.MeshStandardMaterial({ color: 0x4e342e, roughness: 1.0 }),
        leaf: new THREE.MeshStandardMaterial({ color: 0x1b5e20, roughness: 0.8, flatShading: true }),
        glowYellow: new THREE.MeshStandardMaterial({ 
            color: 0xffd54f, emissive: 0xffa000, emissiveIntensity: 4 
        }),
        gold: new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 }),
        red: new THREE.MeshStandardMaterial({ color: 0xd32f2f, roughness: 0.3, metalness: 0.1 }),
        silver: new THREE.MeshStandardMaterial({ color: 0xe0e0e0, metalness: 0.9, roughness: 0.1 }),
        blue: new THREE.MeshStandardMaterial({ color: 0x1976d2, roughness: 0.3, metalness: 0.1 }),
        lampPost: new THREE.MeshStandardMaterial({ color: 0x212121, metalness: 0.5, roughness: 0.5 })
    };

    // --- [ìˆ˜ì •] ë¬´í•œíˆ ë„“ì€ ë°”ë‹¥ ---
    const ground = new THREE.Mesh(
        new THREE.CylinderGeometry(CONFIG.groundSize, CONFIG.groundSize, 10, 64),
        materials.snow
    );
    ground.position.y = -5; // ì‚´ì§ ë‚´ë ¤ì„œ ë°°ì¹˜
    ground.receiveShadow = true;
    scene.add(ground);

    // --- [ì¶”ê°€] ì˜ˆìœ ë°¤í•˜ëŠ˜ (ê·¸ë¼ë°ì´ì…˜ + ë³„) ---
    let stars; // ì „ì—­ ë³€ìˆ˜ë¡œ ì„ ì–¸í•˜ì—¬ ì• ë‹ˆë©”ì´ì…˜ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•˜ê²Œ í•¨
    function createGradientSky() {
        // 1. ê·¸ë¼ë°ì´ì…˜ í•˜ëŠ˜ (Vertex Colors í™œìš©)
        const skyGeo = new THREE.SphereGeometry(CONFIG.skySize, 32, 32);
        const count = skyGeo.attributes.position.count;
        const colors = [];
        const colorTop = new THREE.Color(0x050814); // ì²œì •: ê¹Šì€ ê²€í‘¸ë¥¸ìƒ‰
        const colorBot = new THREE.Color(0x2d3663); // ì§€í‰ì„ : ì€ì€í•œ ë‚¨ë³´ë¼ë¹›
        const colorWhite = new THREE.Color(0xffffff); // [ì¶”ê°€] í•˜ì–€ìƒ‰

        for(let i = 0; i < count; i++) {
            const y = skyGeo.attributes.position.getY(i);
            
            // [ìˆ˜ì •] ì§€í‰ì„ (y=0) ì•„ë˜ëŠ” í•˜ì–€ìƒ‰ìœ¼ë¡œ ì±„ì›€
            if (y < 0) {
                colors.push(colorWhite.r, colorWhite.g, colorWhite.b);
            } else {
                // ì§€í‰ì„  ìœ„ëŠ” ê¸°ì¡´ ê·¸ë¼ë°ì´ì…˜ ì ìš©
                // yëŠ” 0 ~ CONFIG.skySize ë²”ìœ„. të¥¼ 0 ~ 1ë¡œ ë§¤í•‘
                let t = y / CONFIG.skySize; 
                t = Math.pow(t, 0.8); // ê·¸ë¼ë°ì´ì…˜ ë¶„í¬ ì¡°ì ˆ
                
                const c = colorBot.clone().lerp(colorTop, t);
                colors.push(c.r, c.g, c.b);
            }
        }

        skyGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        
        const skyMat = new THREE.MeshBasicMaterial({ 
            vertexColors: true, 
            side: THREE.BackSide, // ì•ˆìª½ ë©´ì„ ë Œë”ë§
            fog: false // ì•ˆê°œ ì˜í–¥ì„ ë°›ì§€ ì•Šë„ë¡ (ì„ ëª…í•œ í•˜ëŠ˜)
        });
        
        const skyDome = new THREE.Mesh(skyGeo, skyMat);
        scene.add(skyDome);

        // 2. ë°°ê²½ ë³„ (ë©€ë¦¬ì„œ ë°˜ì§ì´ëŠ” ë³„ë“¤)
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        const starInitialOpacities = []; // ì´ˆê¸° íˆ¬ëª…ë„ ì €ì¥ìš© ë°°ì—´
        for(let i=0; i<1500; i++) {
            const r = CONFIG.skySize * 0.9; // í•˜ëŠ˜ ë”ë³´ë‹¤ ì•½ê°„ ì•ˆìª½
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            
            // ìœ„ìª½ ë°˜êµ¬ì—ë§Œ ë³„ ë°°ì¹˜ (ì§€í‰ì„  ì•„ë˜ëŠ” ë°”ë‹¥ì´ë¯€ë¡œ ì œì™¸í•´ë„ ë¨)
            if (phi > Math.PI / 1.8) continue; 

            starPos.push(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.cos(phi), // Yì¶•ì´ ìœ„
                r * Math.sin(phi) * Math.sin(theta)
            );
            starInitialOpacities.push(0.5 + Math.random() * 0.5); // 0.5 ~ 1.0 ì‚¬ì´ì˜ ëœë¤ ì´ˆê¸° íˆ¬ëª…ë„
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        // ê° ë³„ì˜ íˆ¬ëª…ë„ë¥¼ ê°œë³„ì ìœ¼ë¡œ ì¡°ì ˆí•˜ê¸° ìœ„í•´ alpha ì†ì„± ì¶”ê°€
        starGeo.setAttribute('alpha', new THREE.Float32BufferAttribute(starInitialOpacities, 1));

        // ì»¤ìŠ¤í…€ ì…°ì´ë” ì¬ì§ˆì„ ì‚¬ìš©í•˜ì—¬ ê° ë³„ì˜ alpha ê°’ì„ ì ìš©
        const starMat = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0.0 }
            },
            vertexShader: `
                attribute float alpha;
                varying float vAlpha;
                void main() {
                    vAlpha = alpha;
                    gl_PointSize = 8.0;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying float vAlpha;
                void main() {
                    // ì‹œê°„ì— ë”°ë¼ ë°˜ì§ì´ëŠ” íš¨ê³¼ (ì‚¬ì¸íŒŒ ì´ìš©)
                    float twinkle = 0.7 + 0.3 * sin(time * 2.0 + vAlpha * 10.0);
                    gl_FragColor = vec4(1.0, 1.0, 1.0, vAlpha * twinkle);
                }
            `,
            transparent: true,
            fog: false
        });
        stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);
    }

    // --- ëˆˆì†¡ì´ (ë–¨ì–´ì§€ëŠ” ëˆˆ) ---
    let snowSystem;
    function createSnow() {
        const geo = new THREE.BufferGeometry();
        const positions = [];
        const velocities = [];
        const range = 400; // ëˆˆ ë‚´ë¦¬ëŠ” ë²”ìœ„ëŠ” ë§ˆì„ ê·¼ì²˜ë¡œ ìœ ì§€

        for (let i = 0; i < CONFIG.snowCount; i++) {
            positions.push(
                (Math.random() - 0.5) * range,
                Math.random() * 150,
                (Math.random() - 0.5) * range
            );
            velocities.push(Math.random() * 0.3 + 0.1);
        }

        geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        
        // ê°„ë‹¨í•œ ì›í˜• í…ìŠ¤ì²˜ ìƒì„±
        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
        grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 32, 32);

        const mat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 1.2,
            map: new THREE.CanvasTexture(canvas),
            transparent: true,
            opacity: 0.9,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        snowSystem = new THREE.Points(geo, mat);
        snowSystem.userData = { velocities: velocities };
        scene.add(snowSystem);
    }

    // --- ì†Œë‚˜ë¬´ ---
    function createPineTree(x, z, scale = 1) {
        const group = new THREE.Group();
        
        const trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.5 * scale, 1 * scale, 3 * scale, 6),
            materials.darkWood
        );
        trunk.position.y = 1.5 * scale;
        trunk.castShadow = true;
        group.add(trunk);

        for(let i=0; i<3; i++) {
            const size = (2.5 - i * 0.5) * scale;
            const y = (3 + i * 2) * scale;
            const cone = new THREE.Mesh(
                new THREE.ConeGeometry(size, 3 * scale, 7),
                materials.leaf
            );
            cone.position.y = y;
            cone.castShadow = true;
            cone.receiveShadow = true;
            group.add(cone);

            const snowCap = new THREE.Mesh(
                new THREE.ConeGeometry(size * 0.9, 1 * scale, 7),
                materials.snow
            );
            snowCap.position.y = y - 0.5 * scale;
            snowCap.rotation.y = Math.random();
            group.add(snowCap);
        }

        group.position.set(x, 0, z);
        group.rotation.y = Math.random() * Math.PI * 2;
        const randScale = 0.8 + Math.random() * 0.4;
        group.scale.set(randScale, randScale, randScale);
        scene.add(group);
    }

    // --- ê°€ë¡œë“± ---
    function createLamp(x, z) {
        const group = new THREE.Group();
        const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 8, 6), materials.lampPost);
        pole.position.y = 4;
        pole.castShadow = true;
        group.add(pole);

        const head = new THREE.Mesh(new THREE.DodecahedronGeometry(0.8), materials.glowYellow);
        head.position.y = 8;
        group.add(head);

        const light = new THREE.PointLight(0xffaa00, 1.5, 15);
        light.position.y = 8;
        group.add(light);

        group.position.set(x, 0, z);
        scene.add(group);
    }

    // --- ëˆˆì‚¬ëŒ ---
    function createSnowman(x, z) {
        const group = new THREE.Group();
        const bottom = new THREE.Mesh(new THREE.SphereGeometry(1.5, 12, 12), materials.snow);
        bottom.position.y = 1.2;
        bottom.castShadow = true;
        
        const top = new THREE.Mesh(new THREE.SphereGeometry(1.0, 12, 12), materials.snow);
        top.position.y = 3.2;
        top.castShadow = true;

        const nose = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.8, 8), materials.red);
        nose.geometry.rotateX(Math.PI / 2);
        nose.position.set(0, 3.2, 0.9);

        const hat = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 1, 8), materials.lampPost);
        hat.position.set(0, 4.2, 0);

        group.add(bottom, top, nose, hat);
        group.position.set(x, 0, z);
        group.rotation.y = (Math.random() - 0.5) * 1;
        scene.add(group);
    }

    // --- ì„ ë¬¼ ---
    function createGift(x, z) {
        const size = 1 + Math.random();
        const box = new THREE.Mesh(
            new THREE.BoxGeometry(size, size, size),
            new THREE.MeshStandardMaterial({ 
                color: Math.random() > 0.5 ? 0xd32f2f : 0x1976d2,
                roughness: 0.4
            })
        );
        box.position.set(x, size/2, z);
        box.rotation.y = Math.random();
        box.castShadow = true;
        scene.add(box);
    }

    // --- ì§‘ ---
    function createHouse(x, z, angle) {
        const group = new THREE.Group();
        const w = 7 + Math.random() * 3;
        const d = 7 + Math.random() * 3;
        const h = 6 + Math.random() * 3;

        const walls = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            Math.random() > 0.5 ? materials.wood : materials.darkWood
        );
        walls.position.y = h/2;
        walls.castShadow = true;
        walls.receiveShadow = true;
        group.add(walls);

        const roofH = 4;
        const roof = new THREE.Mesh(
            new THREE.ConeGeometry(Math.max(w,d)*0.8, roofH, 4),
            materials.snow
        );
        roof.position.y = h + roofH/2;
        roof.rotation.y = Math.PI/4;
        roof.scale.set(1, 1, w > d ? 0.6 : 1.4);
        roof.castShadow = true;
        group.add(roof);

        const win = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 1.2), materials.glowYellow);
        win.position.set(0, h/2, d/2 + 0.05);
        group.add(win);
        
        const door = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 3), materials.darkWood);
        door.position.set(w/4, 1.5, d/2 + 0.06);
        group.add(door);

        group.position.set(x, 0, z);
        group.rotation.y = angle;
        scene.add(group);
    }

    // --- ë©”ì¸ íŠ¸ë¦¬ ---
    const ornaments = [];
    let fairyLightsSystem;

    function createMainTree() {
        const group = new THREE.Group();

        const levels = 7;
        const maxRadius = 10;
        const treeHeight = 35;

        // ë‚˜ë¬´ ë³¸ì²´
        for(let i=0; i<levels; i++) {
            const ratio = i / levels;
            const r = maxRadius * (1 - ratio * 0.8); 
            const y = 3 + i * 4;
            
            const cone = new THREE.Mesh(
                new THREE.ConeGeometry(r, 8, 10),
                materials.leaf
            );
            cone.position.y = y;
            cone.castShadow = true;
            cone.receiveShadow = true;
            group.add(cone);

            if(i < levels-1) {
                const snowRing = new THREE.Mesh(
                    new THREE.TorusGeometry(r * 0.9, 0.2, 2, 10),
                    materials.snow
                );
                snowRing.position.y = y - 3.5;
                snowRing.rotation.x = Math.PI / 2;
                group.add(snowRing);
            }
        }

        // ì˜¤ë„ˆë¨¼íŠ¸
        for(let i=0; i<levels; i++) {
            const r = maxRadius * (1 - i / levels * 0.8);
            const y = 3 + i * 4;
            const count = 10 - i; 
            if(count < 3) continue;

            for(let j=0; j<count; j++) {
                const angle = (j / count) * Math.PI * 2 + (i * 0.5);
                const ox = Math.cos(angle) * r * 0.85; 
                const oz = Math.sin(angle) * r * 0.85;

                const rand = Math.random();
                let mat = materials.red;
                if(rand > 0.75) mat = materials.gold;
                else if(rand > 0.5) mat = materials.silver;
                else if(rand > 0.25) mat = materials.blue;

                const size = 0.4 + Math.random() * 0.2;
                const ball = new THREE.Mesh(new THREE.SphereGeometry(size, 8, 8), mat);
                ball.position.set(ox, y - 3, oz);
                group.add(ball);

                if(Math.random() > 0.8) {
                    ball.material = materials.glowYellow;
                    ornaments.push({ mesh: ball, offset: Math.random() * 10 });
                }
            }
        }

        // ë¦¬ë³¸
        const points = [];
        const loops = 5;
        const hStart = 3;
        const hEnd = 30;
        for(let i = 0; i <= 150; i++) {
            const t = i / 150;
            const angle = t * Math.PI * 2 * loops;
            const y = hStart + t * (hEnd - hStart);
            const currentR = maxRadius * (1 - t * 0.9) + 0.2;
            points.push(new THREE.Vector3(Math.cos(angle) * currentR, y, Math.sin(angle) * currentR));
        }
        const ribbon = new THREE.Mesh(
            new THREE.TubeGeometry(new THREE.CatmullRomCurve3(points), 100, 0.3, 8, false),
            materials.gold
        );
        ribbon.castShadow = true;
        group.add(ribbon);

        // ìš”ì • ì¡°ëª…
        const fairyGeo = new THREE.BufferGeometry();
        const fairyPos = [];
        const fairyCount = 300;
        for(let i=0; i<fairyCount; i++) {
            const t = i / fairyCount;
            const angle = t * Math.PI * 2 * 9 + Math.random(); 
            const y = hStart + t * (hEnd - hStart) + (Math.random()-0.5);
            const r = (maxRadius * (1 - t * 0.9)) + 0.4 + (Math.random() * 0.5);
            fairyPos.push(Math.cos(angle) * r, y, Math.sin(angle) * r);
        }
        fairyGeo.setAttribute('position', new THREE.Float32BufferAttribute(fairyPos, 3));
        const fairyMat = new THREE.PointsMaterial({
            color: 0xffe082,
            size: 0.6,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending
        });
        fairyLightsSystem = new THREE.Points(fairyGeo, fairyMat);
        group.add(fairyLightsSystem);

        // ê¼­ëŒ€ê¸° ë³„
        const star = new THREE.Mesh(
            new THREE.OctahedronGeometry(2.5, 0),
            materials.glowYellow
        );
        star.position.y = 32;
        star.userData = { rotationSpeed: 0.02 }; 
        group.add(star);
        ornaments.push({ mesh: star, isStar: true });

        scene.add(group);
    }

    // --- ë£¨ëŒí”„ ì°ë§¤ ---
    let sleighGroup;
    function createSleigh() {
        sleighGroup = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(4, 2, 6), materials.red);
        sleighGroup.add(body);
        
        const light = new THREE.PointLight(0xffffff, 1, 10);
        light.position.set(0, 1, 0);
        sleighGroup.add(light);

        for(let i=0; i<4; i++) {
            const deer = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 2), materials.wood);
            deer.position.set(i%2===0 ? -1.5 : 1.5, -0.5, 5 + Math.floor(i/2)*3);
            if(i >= 2) {
                const nose = new THREE.Mesh(new THREE.SphereGeometry(0.3), materials.glowYellow);
                nose.position.set(0, 0.5, 1);
                deer.add(nose);
            }
            sleighGroup.add(deer);
        }
        scene.add(sleighGroup);
    }

    // --- ì£¼ë¯¼ ---
    const villagers = [];
    function createVillagers() {
        const geo = new THREE.CapsuleGeometry(0.4, 0.8, 4, 8);
        const headGeo = new THREE.SphereGeometry(0.35);

        for(let i=0; i<CONFIG.villagerCount; i++) {
            const group = new THREE.Group();
            const color = new THREE.Color().setHSL(Math.random(), 0.8, 0.4);
            const mat = new THREE.MeshStandardMaterial({ color: color });
            
            const body = new THREE.Mesh(geo, mat);
            body.position.y = 0.8;
            body.castShadow = true;
            
            const head = new THREE.Mesh(headGeo, materials.wood);
            head.position.y = 1.6;
            
            group.add(body, head);
            
            const angle = Math.random() * Math.PI * 2;
            const dist = 15 + Math.random() * 20;
            group.position.set(Math.cos(angle)*dist, 0, Math.sin(angle)*dist);
            
            scene.add(group);
            
            villagers.push({
                mesh: group,
                angle: angle,
                dist: dist,
                speed: 0.003 + Math.random() * 0.004,
                hopOffset: Math.random() * Math.PI
            });
        }
    }

    // --- ì´ˆê¸°í™” ---
    function initWorld() {
        createGradientSky(); // í•˜ëŠ˜ ì¶”ê°€
        createSnow();
        createMainTree();
        createSleigh();
        createVillagers();

        // 1. ì§‘ ë°°ì¹˜
        for(let i=0; i<CONFIG.houseCount; i++) {
            const angle = (i / CONFIG.houseCount) * Math.PI * 2 + (Math.random()*0.2);
            const dist = 35 + Math.random() * 10;
            createHouse(Math.cos(angle)*dist, Math.sin(angle)*dist, -angle + Math.PI/2);
            
            if(Math.random() > 0.3) {
                createLamp(Math.cos(angle)*(dist+6), Math.sin(angle)*(dist+6));
            }
            if(Math.random() > 0.5) {
                createGift(Math.cos(angle)*(dist-4), Math.sin(angle)*(dist-4));
            }
        }

        // 2. ìˆ² ë°°ì¹˜
        for(let i=0; i<CONFIG.treeCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 55 + Math.random() * 60; 
            createPineTree(Math.cos(angle)*dist, Math.sin(angle)*dist, 1 + Math.random()*0.5);
        }

        // 3. ëˆˆì‚¬ëŒ
        for(let i=0; i<5; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 25 + Math.random() * 20;
            createSnowman(Math.cos(angle)*dist, Math.sin(angle)*dist);
        }

        loading.style.opacity = 0;
        setTimeout(() => loading.remove(), 500);
    }
    
    initWorld();

    // --- ì• ë‹ˆë©”ì´ì…˜ ---
    const clock = new THREE.Clock();
    
    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();

        controls.update();

        // [ì¶”ê°€] ë³„ ë°˜ì§ì„ íš¨ê³¼ ì—…ë°ì´íŠ¸
        if (stars && stars.material.uniforms) {
            stars.material.uniforms.time.value = time;
        }

        // ëˆˆ
        if(snowSystem) {
            const pos = snowSystem.geometry.attributes.position.array;
            const vel = snowSystem.userData.velocities;
            for(let i=0; i<CONFIG.snowCount; i++) {
                pos[i*3 + 1] -= vel[i];
                if(pos[i*3+1] < 0) {
                    pos[i*3+1] = 150;
                    pos[i*3] = (Math.random()-0.5) * 400;
                    pos[i*3+2] = (Math.random()-0.5) * 400;
                }
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
            snowSystem.rotation.y = Math.sin(time * 0.1) * 0.1;
        }

        // ì°ë§¤
        if(sleighGroup) {
            const r = 60;
            const h = 40;
            sleighGroup.position.x = Math.sin(time*0.3) * r;
            sleighGroup.position.z = Math.cos(time*0.3) * r;
            sleighGroup.position.y = h + Math.sin(time*0.8)*5;
            sleighGroup.lookAt(
                Math.sin(time*0.3 + 0.1) * r, 
                h, 
                Math.cos(time*0.3 + 0.1) * r
            );
        }

        // ì˜¤ë„ˆë¨¼íŠ¸
        ornaments.forEach(obj => {
            if(obj.isStar) {
                if (obj.mesh.userData && obj.mesh.userData.rotationSpeed) {
                    obj.mesh.rotation.y += obj.mesh.userData.rotationSpeed;
                }
                const s = 1 + Math.sin(time*2)*0.2;
                obj.mesh.scale.set(s,s,s);
            } else {
                obj.mesh.material.emissiveIntensity = 1.5 + Math.sin(time*3 + obj.offset);
            }
        });

        if(fairyLightsSystem) {
            fairyLightsSystem.rotation.y = time * 0.05;
            const blink = 0.7 + Math.sin(time * 3) * 0.3;
            fairyLightsSystem.material.opacity = blink;
        }

        // ì£¼ë¯¼
        villagers.forEach(v => {
            v.angle += v.speed;
            v.mesh.position.x = Math.cos(v.angle) * v.dist;
            v.mesh.position.z = Math.sin(v.angle) * v.dist;
            v.mesh.rotation.y = -v.angle;
            v.mesh.position.y = Math.abs(Math.sin(time*8 + v.hopOffset)) * 0.6;
        });

        renderer.render(scene, camera);
    }
    
    animate();

    // ë¦¬ì‚¬ì´ì¦ˆ
    window.addEventListener('resize', () => {
        const aspect = window.innerWidth / window.innerHeight;
        camera.left = -d * aspect;
        camera.right = d * aspect;
        camera.top = d;
        camera.bottom = -d;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
